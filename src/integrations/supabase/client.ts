// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database, BlogPost } from './types';

// Security: Require environment variables - no hardcoded fallbacks
const SUPABASE_URL = (import.meta as any).env?.VITE_SUPABASE_URL;
const SUPABASE_PUBLISHABLE_KEY = (import.meta as any).env?.VITE_SUPABASE_ANON_KEY;

if (!SUPABASE_URL || !SUPABASE_PUBLISHABLE_KEY) {
  const missing = [];
  if (!SUPABASE_URL) missing.push('VITE_SUPABASE_URL');
  if (!SUPABASE_PUBLISHABLE_KEY) missing.push('VITE_SUPABASE_ANON_KEY');
  throw new Error(
    `Missing required Supabase environment variables: ${missing.join(', ')}. ` +
    `Please set these in your .env file. See .env.example for reference.`
  );
}

// Create a safe storage fallback for environments where localStorage is not available
function getSafeLocalStorage() {
  try {
    if (typeof window !== 'undefined' && window.localStorage) {
      // Test access
      const testKey = '__test__';
      window.localStorage.setItem(testKey, '1');
      window.localStorage.removeItem(testKey);
      return window.localStorage;
    }
  } catch (e) {
    // localStorage is not available (private mode, security, etc.)
  }
  // Fallback: in-memory storage (not persistent)
  let store: Record<string, string> = {};
  return {
    getItem: (key: string) => (key in store ? store[key] : null),
    setItem: (key: string, value: string) => { store[key] = value; },
    removeItem: (key: string) => { delete store[key]; },
    clear: () => { store = {}; },
  };
}

// Defensive: intercept fetch calls that would send 'eq.undefined' in query params
// This prevents PostgREST requests like `.../products?id=eq.undefined` which
// cause Postgres UUID parsing errors. We block those requests early and log
// a helpful message to aid debugging; callers should still be fixed to avoid
// passing undefined IDs.
try {
  const globalAny: any = typeof globalThis !== 'undefined' ? globalThis : (typeof window !== 'undefined' ? window : undefined);
  if (globalAny && typeof globalAny.fetch === 'function') {
    const _origFetch = globalAny.fetch.bind(globalAny);
    globalAny.fetch = async (input: any, init?: any) => {
      try {
        const url = typeof input === 'string' ? input : input?.url || '';
        if (typeof url === 'string' && url.includes('=eq.undefined')) {
          const stack = (new Error()).stack;
          console.error('[supabase][block] Prevented request with undefined id in query:', url);
          if (stack) console.error('[supabase][block] Stack trace for blocked request:\n', stack);
          const body = JSON.stringify({
            message: 'Blocked request: query contained undefined id',
            details: 'Request blocked by client-side guard to avoid invalid UUID parsing on server',
            client_stack: stack || null
          });
          return new Response(body, { status: 400, headers: { 'Content-Type': 'application/json' } });
        }
      } catch (err) {
        // swallow and fallthrough to original fetch
      }
      return _origFetch(input, init);
    };
  }
} catch (e) {
  // ignore in environments where fetch override isn't permitted
}

// Create Supabase client with proper configuration
export const supabase = createClient<Database>(
  SUPABASE_URL,
  SUPABASE_PUBLISHABLE_KEY,
  {
    auth: {
      persistSession: true,
      storageKey: 'smart-inventory-auth',
      storage: getSafeLocalStorage(),
      autoRefreshToken: true,
      detectSessionInUrl: true,  // <-- Enable this to handle session tokens from URL automatically
    },
    global: {
      headers: {
        'x-application-name': 'smart-inventory'
      }
    }
  }
);

// Listen for auth state changes
supabase.auth.onAuthStateChange(() => {
  // Auth state change logging removed for production security
});

// Export a function to check connection with timeout
export const checkSupabaseConnection = async () => {
  try {
    // Create a shorter timeout for better UX
    const timeoutPromise = new Promise((_, reject) => {
      setTimeout(() => reject(new Error('Connection timeout')), 3000); // 3 second timeout
    });
    
    // Try auth session check (lightest operation, doesn't require database access)
    try {
      const authCheck = await Promise.race([
        supabase.auth.getSession(),
        timeoutPromise
      ]) as any;
      
      // If we get here, the connection is working (even if no session exists)
      // getSession() only requires API access, not database access
      return true;
    } catch (authError) {
      // Timeout or network error - this is expected in offline scenarios
      console.warn('Supabase auth check failed:', authError);
      return false;
    }
  } catch (error) {
    // Unexpected error - log but don't fail the app
    console.warn('Supabase connection test exception:', error);
    // Return false to indicate connection issues - offline mode will handle this
    return false;
  }
};

// BlogPost CRUD functions
export async function fetchBlogPosts(): Promise<BlogPost[]> {
  const { data, error } = await supabase.from('blogposts').select('*').order('date_published', { ascending: false });
  if (error) throw error;
  return data || [];
}

export async function addBlogPost(post: Omit<BlogPost, 'id'>): Promise<BlogPost> {
  const insertData = {
    title: post.title,
    slug: post.slug,
    content: post.content,
    author: post.author || null,
    date_published: post.date_published || null,
    published: post.published,
    excerpt: null,
  };
  const { data, error } = await supabase
    .from('blogposts')
    .insert([insertData])
    .select();
  if (error) throw error;
  return data?.[0] as BlogPost;
}

export async function updateBlogPost(id: string, post: Partial<BlogPost>): Promise<BlogPost> {
  const updateData = {
    title: post.title,
    slug: post.slug,
    content: post.content,
    author: post.author,
    date_published: post.date_published,
    published: post.published,
  };
  const { data, error } = await supabase.from('blogposts').update(updateData).eq('id', id).select();
  if (error) throw error;
  return data?.[0] as BlogPost;
}

export async function deleteBlogPost(id: string): Promise<BlogPost[]> {
  // Use array response to avoid 406 when zero rows are returned
  const { data, error } = await supabase
    .from('blogposts')
    .delete()
    .eq('id', id)
    .select('*');
  if (error) throw error;
  return data || [];
}

export async function fetchBlogPostBySlug(slug: string): Promise<BlogPost | null> {
  const { data, error } = await supabase
    .from('blogposts')
    .select('*')
    .eq('slug', slug)
    .single();
  
  if (error) {
    if (error.code === 'PGRST116') { // Record not found
      return null;
    }
    throw error;
  }
  
  return data;
}

// Auth Conversion Tracking functions
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';
import type { BlogPost, AuthConversionEvent, AuthConversionAnalytics, AuthConversionFunnel } from './types';

const SUPABASE_URL = (import.meta as any).env?.VITE_SUPABASE_URL || "https://sszuxnqhbxauvershuys.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = (import.meta as any).env?.VITE_SUPABASE_ANON_KEY || "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InNzenV4bnFoYnhhdXZlcnNodXlzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDk4OTEyODYsImV4cCI6MjA2NTQ2NzI4Nn0.-jvEJ1uUwdcJKZ1JbgOtD6jr-e0FoeepPrj8rpSFviQ";

if (!SUPABASE_URL || !SUPABASE_PUBLISHABLE_KEY) {
  throw new Error('Missing Supabase credentials');
}

// Create a safe storage fallback for environments where localStorage is not available
function getSafeLocalStorage() {
  try {
    if (typeof window !== 'undefined' && window.localStorage) {
      // Test access
      const testKey = '__test__';
      window.localStorage.setItem(testKey, '1');
      window.localStorage.removeItem(testKey);
      return window.localStorage;
    }
  } catch (e) {
    // localStorage is not available (private mode, security, etc.)
  }
  // Fallback: in-memory storage (not persistent)
  let store: Record<string, string> = {};
  return {
    getItem: (key: string) => (key in store ? store[key] : null),
    setItem: (key: string, value: string) => { store[key] = value; },
    removeItem: (key: string) => { delete store[key]; },
    clear: () => { store = {}; },
  };
}

// Create Supabase client with proper configuration
export const supabase = createClient<Database>(
  SUPABASE_URL,
  SUPABASE_PUBLISHABLE_KEY,
  {
    auth: {
      persistSession: true,
      storageKey: 'smart-inventory-auth',
      storage: getSafeLocalStorage(),
      autoRefreshToken: true,
      detectSessionInUrl: true,  // <-- Enable this to handle session tokens from URL automatically
    },
    global: {
      headers: {
        'x-application-name': 'smart-inventory'
      }
    }
  }
);

// Listen for auth state changes
supabase.auth.onAuthStateChange(() => {
  // Auth state change logging removed for production security
});

// Export a function to check connection with timeout
export const checkSupabaseConnection = async () => {
  try {
    // Create a shorter timeout for better UX
    const timeoutPromise = new Promise((_, reject) => {
      setTimeout(() => reject(new Error('Connection timeout')), 3000); // 3 second timeout
    });
    
    // Try auth session check (lightest operation, doesn't require database access)
    try {
      const authCheck = await Promise.race([
        supabase.auth.getSession(),
        timeoutPromise
      ]) as any;
      
      // If we get here, the connection is working (even if no session exists)
      // getSession() only requires API access, not database access
      return true;
    } catch (authError) {
      // Timeout or network error - this is expected in offline scenarios
      console.warn('Supabase auth check failed:', authError);
      return false;
    }
  } catch (error) {
    // Unexpected error - log but don't fail the app
    console.warn('Supabase connection test exception:', error);
    // Return false to indicate connection issues - offline mode will handle this
    return false;
  }
};

// BlogPost CRUD functions
export async function fetchBlogPosts(): Promise<BlogPost[]> {
  const { data, error } = await supabase.from('blogposts').select('*').order('date_published', { ascending: false });
  if (error) throw error;
  return data || [];
}

export async function addBlogPost(post: Omit<BlogPost, 'id'>): Promise<BlogPost> {
  const insertData = [post as any];
  const { data, error } = await supabase.from('blogposts').insert(insertData as any).select();
  if (error) throw error;
  return data?.[0] as BlogPost;
}

export async function updateBlogPost(id: string, post: Partial<BlogPost>): Promise<BlogPost> {
  const updateData = post as any;
  const { data, error } = await supabase.from('blogposts').update(updateData as any).eq('id', id).select();
  if (error) throw error;
  return data?.[0] as BlogPost;
}

export async function deleteBlogPost(id: string): Promise<BlogPost[]> {
  // Use array response to avoid 406 when zero rows are returned
  const { data, error } = await supabase
    .from('blogposts')
    .delete()
    .eq('id', id)
    .select('*');
  if (error) throw error;
  return data || [];
}

export async function fetchBlogPostBySlug(slug: string): Promise<BlogPost | null> {
  const { data, error } = await supabase
    .from('blogposts')
    .select('*')
    .eq('slug', slug)
    .single();
  
  if (error) {
    if (error.code === 'PGRST116') { // Record not found
      return null;
    }
    throw error;
  }
  
  return data;
}

// Auth Conversion Tracking functions
export async function trackAuthConversionEvent(event: Omit<AuthConversionEvent, 'id' | 'created_at' | 'updated_at'>): Promise<void> {
  try {
    const insertData = [event as any];
    const { error } = await supabase.from('auth_conversion_events').insert(insertData as any);
    if (error) {
      // Silently fail if table doesn't exist (404) - tracking is optional
      if (error.code !== 'PGRST116' && !error.message?.includes('404')) {
        console.error('Failed to track auth conversion event:', error);
      }
    }
  } catch (error: any) {
    // Silently fail for 404 errors - table may not exist yet
    if (!error?.message?.includes('404')) {
      console.error('Error tracking auth conversion event:', error);
    }
  }
}

export async function getAuthConversionAnalytics(startDate?: string, endDate?: string): Promise<AuthConversionAnalytics[]> {
  try {
    let query = supabase.from('auth_conversion_analytics').select('*');
    
    if (startDate) {
      query = query.gte('date', startDate);
    }
    
    if (endDate) {
      query = query.lte('date', endDate);
    }
    
    const { data, error } = await query.order('date', { ascending: false });
    
    if (error) {
      console.error('Failed to fetch auth conversion analytics:', error);
      return [];
    }
    
    return data || [];
  } catch (error) {
    console.error('Error fetching auth conversion analytics:', error);
    return [];
  }
}

export async function getAuthConversionFunnel(startDate?: string, endDate?: string): Promise<AuthConversionFunnel[]> {
  try {
    let query = supabase.from('auth_conversion_funnel').select('*');
    
    if (startDate) {
      query = query.gte('date', startDate);
    }
    
    if (endDate) {
      query = query.lte('date', endDate);
    }
    
    const { data, error } = await query.order('date', { ascending: false });
    
    if (error) {
      console.error('Failed to fetch auth conversion funnel:', error);
      return [];
    }
    
    return data || [];
  } catch (error) {
    console.error('Error fetching auth conversion funnel:', error);
    return [];
  }
}

export async function getAuthConversionEventsBySession(sessionId: string): Promise<AuthConversionEvent[]> {
  try {
    const { data, error } = await supabase
      .from('auth_conversion_events')
      .select('*')
      .eq('session_id', sessionId)
      .order('created_at', { ascending: true });
    
    if (error) {
      console.error('Failed to fetch auth conversion events by session:', error);
      return [];
    }
    
    return data || [];
  } catch (error) {
    console.error('Error fetching auth conversion events by session:', error);
    return [];
  }
}

// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database, BlogPost } from './types';

const SUPABASE_URL = (import.meta as any).env?.VITE_SUPABASE_URL || "https://sszuxnqhbxauvershuys.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = (import.meta as any).env?.VITE_SUPABASE_ANON_KEY || "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InNzenV4bnFoYnhhdXZlcnNodXlzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDk4OTEyODYsImV4cCI6MjA2NTQ2NzI4Nn0.-jvEJ1uUwdcJKZ1JbgOtD6jr-e0FoeepPrj8rpSFviQ";

if (!SUPABASE_URL || !SUPABASE_PUBLISHABLE_KEY) {
  throw new Error('Missing Supabase credentials');
}

// Create a safe storage fallback for environments where localStorage is not available
function getSafeLocalStorage() {
  try {
    if (typeof window !== 'undefined' && window.localStorage) {
      // Test access
      const testKey = '__test__';
      window.localStorage.setItem(testKey, '1');
      window.localStorage.removeItem(testKey);
      return window.localStorage;
    }
  } catch (e) {
    // localStorage is not available (private mode, security, etc.)
  }
  // Fallback: in-memory storage (not persistent)
  let store: Record<string, string> = {};
  return {
    getItem: (key: string) => (key in store ? store[key] : null),
    setItem: (key: string, value: string) => { store[key] = value; },
    removeItem: (key: string) => { delete store[key]; },
    clear: () => { store = {}; },
  };
}

// Create Supabase client with proper configuration
export const supabase = createClient<Database>(
  SUPABASE_URL,
  SUPABASE_PUBLISHABLE_KEY,
  {
    auth: {
      persistSession: true,
      storageKey: 'smart-inventory-auth',
      storage: getSafeLocalStorage(),
      autoRefreshToken: true,
      detectSessionInUrl: true,  // <-- Enable this to handle session tokens from URL automatically
    },
    global: {
      headers: {
        'x-application-name': 'smart-inventory'
      }
    }
  }
);

// Listen for auth state changes
supabase.auth.onAuthStateChange(() => {
  // Auth state change logging removed for production security
});

// Export a function to check connection with timeout
export const checkSupabaseConnection = async () => {
  try {
    // Create a shorter timeout for better UX
    const timeoutPromise = new Promise((_, reject) => {
      setTimeout(() => reject(new Error('Connection timeout')), 3000); // 3 second timeout
    });
    
    // Try auth session check (lightest operation, doesn't require database access)
    try {
      const authCheck = await Promise.race([
        supabase.auth.getSession(),
        timeoutPromise
      ]) as any;
      
      // If we get here, the connection is working (even if no session exists)
      // getSession() only requires API access, not database access
      return true;
    } catch (authError) {
      // Timeout or network error - this is expected in offline scenarios
      console.warn('Supabase auth check failed:', authError);
      return false;
    }
  } catch (error) {
    // Unexpected error - log but don't fail the app
    console.warn('Supabase connection test exception:', error);
    // Return false to indicate connection issues - offline mode will handle this
    return false;
  }
};

// BlogPost CRUD functions
export async function fetchBlogPosts(): Promise<BlogPost[]> {
  const { data, error } = await supabase.from('blogposts').select('*').order('date_published', { ascending: false });
  if (error) throw error;
  return data || [];
}

export async function addBlogPost(post: Omit<BlogPost, 'id'>): Promise<BlogPost> {
  const insertData = {
    title: post.title,
    slug: post.slug,
    content: post.content,
    author: post.author || null,
    date_published: post.date_published || null,
    published: post.published,
    excerpt: null,
  };
  const { data, error } = await supabase
    .from('blogposts')
    .insert([insertData])
    .select();
  if (error) throw error;
  return data?.[0] as BlogPost;
}

export async function updateBlogPost(id: string, post: Partial<BlogPost>): Promise<BlogPost> {
  const updateData = {
    title: post.title,
    slug: post.slug,
    content: post.content,
    author: post.author,
    date_published: post.date_published,
    published: post.published,
  };
  const { data, error } = await supabase.from('blogposts').update(updateData).eq('id', id).select();
  if (error) throw error;
  return data?.[0] as BlogPost;
}

export async function deleteBlogPost(id: string): Promise<BlogPost[]> {
  // Use array response to avoid 406 when zero rows are returned
  const { data, error } = await supabase
    .from('blogposts')
    .delete()
    .eq('id', id)
    .select('*');
  if (error) throw error;
  return data || [];
}

export async function fetchBlogPostBySlug(slug: string): Promise<BlogPost | null> {
  const { data, error } = await supabase
    .from('blogposts')
    .select('*')
    .eq('slug', slug)
    .single();
  
  if (error) {
    if (error.code === 'PGRST116') { // Record not found
      return null;
    }
    throw error;
  }
  
  return data;
}

// Auth Conversion Tracking functions